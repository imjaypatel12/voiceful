<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Voiceful Order Notifications</title>
  
  <!-- Import Materialize CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
  
  <!-- Import Google Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  
  <!-- Custom Styles -->
  <link href="styles.css" rel="stylesheet">
</head>
<body>
  <h3>Voiceful Order Notifications</h3>
  <div class="container">
    <div class="row">
      <div class="col s12">
        <label>Client ID:</label>
        <input id="clientId" type="text" placeholder="Enter client/clientId" />
        <button id="register" class="btn waves-effect waves-light">Connect</button>
      </div>
    </div>
    <div class="row">
      <div class="col s12">
        <pre id="logs"></pre>
      </div>
    </div>
    <div id="advancedTools" style="display: none;">
      <hr />
      <h3>Advanced Tools</h3>
      <!-- Updated Broadcast UI section to notify a specific client -->
      <div id="broadcastSection" class="row">
        <div class="col s12">
          <label>Client ID:</label>
          <input id="targetClientId" type="text" placeholder="Enter target clientId" />
        </div>
        <div class="col s12">
          <label>Message:</label>
          <input id="msg" type="text" placeholder="Optional" />
        </div>
        <div class="col s12">
          <button id="send" class="btn waves-effect waves-light">Notify</button>
        </div>
      </div>
    </div>
    
    <!-- New Printers Section -->
    <div class="row">
      <div class="col s12">
        <h5>Connected Printers</h5>
        <button id="refreshPrinters" class="btn waves-effect waves-light">Refresh Printers</button>
        <ul id="connectedPrinters" class="collection"></ul>
        
        <!-- New Print Button -->
        <button id="printHello" class="btn waves-effect waves-light" style="margin-top: 15px;">Print Hello World</button>
      </div>
    </div>

    <!-- New Subnet Input Field -->
    <div class="row">
      <div class="col s12">
        <label for="subnet">Subnet:</label>
        <input id="subnet" type="text" placeholder="Enter subnet (e.g., 192.168.1.)" value="192.168.1." />
      </div>
    </div>
  </div>

  <script>
    let ws;
    let isConnected = false;
    let audioContext = new AudioContext();

    function log(message) {
      const logs = document.getElementById('logs');
      logs.textContent = message + '\n';
    }

    function beep() {
      if (audioContext) {
        // Resume AudioContext if it's suspended
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        const oscillator = audioContext.createOscillator();
        oscillator.type = "sine";
        oscillator.frequency.value = 800;
        oscillator.connect(audioContext.destination);
        oscillator.start();
        // Beep for 300 milliseconds
        setTimeout(function () {
            oscillator.stop();
        }, 300);


      } else {
        console.warn('AudioContext not initialized.');
      }
    }

    // Parse the 'root' and 'clientId' query parameters from the page URL
    const urlParams = new URLSearchParams(window.location.search);
    const root = urlParams.get('root') === 'true';
    const queryClientId = urlParams.get('clientId');
    document.getElementById('advancedTools').style.display = root ? 'block' : 'none';
    document.getElementById('clientId').value = queryClientId || '';

    document.getElementById('register').addEventListener('click', () => {
      if (!isConnected) {
        const clientId = document.getElementById('clientId').value.trim();
        if (!clientId) {
          log('Please enter a valid Client ID.');
          return;
        }

        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        const wsUrl = `${protocol}${window.location.host}`;
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
          ws.send(JSON.stringify({ type: 'registration', clientId }));
          log('Listening for new orders at ' + clientId);
          // Update UI to reflect connected state
          document.getElementById('register').textContent = 'Disconnect';
          document.getElementById('clientId').disabled = true;
          isConnected = true;
        };

        ws.onmessage = (event) => {
          const data = JSON.parse(event.data);                     // disabled to avoid data pileups
          log(data.text);
          beep();
        };

        ws.onclose = () => {
          const clientId = document.getElementById('clientId').value.trim();
          log('Connection closed for ' + clientId);
          // Revert UI to reflect disconnected state
          document.getElementById('register').textContent = 'Connect';
          document.getElementById('clientId').disabled = false;
          isConnected = false;
        };
      } else {
        // Disconnect logic
        if (ws) {
          ws.close();
          log('Disconnecting...');
        }
      }
    });

    document.getElementById('send').addEventListener('click', () => {
      const targetClientId = document.getElementById('targetClientId').value.trim();
      let text = document.getElementById('msg').value.trim();
      
      if (!targetClientId) {
        log('Please enter a valid Client ID.');
        return;
      }

      fetch('/notify', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ clientId: targetClientId, message: text })
      })
      .then(response => response.json())
      .then(data => {
        if (!data.success) {
          log(`Error: ${data.error}`);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        log('Failed to send notification.');
      });
    });

    // New: Load Printers
    document.getElementById('refreshPrinters').addEventListener('click', loadPrinters);

    function loadPrinters() {
      const subnet = document.getElementById('subnet').value.trim();
      if (!isValidSubnet(subnet)) {
        log('Please enter a valid subnet (e.g., 192.168.1.).');
        return;
      }

      fetch(`/printers?subnet=${encodeURIComponent(subnet)}`)
        .then(response => response.json())
        .then(data => {
          const printerList = data.printers;
          const connectedPrinters = document.getElementById('connectedPrinters');
          connectedPrinters.innerHTML = ''; // Clear existing list

          if (printerList.length === 0) {
            connectedPrinters.innerHTML = '<li class="collection-item">No printers found.</li>';
            return;
          }

          // Group printers by type
          const groupedPrinters = printerList.reduce((groups, printer) => {
            const type = printer.type;
            if (!groups[type]) {
              groups[type] = [];
            }
            groups[type].push(printer);
            return groups;
          }, {});

          // Iterate over each group and append to the list with separators
          Object.keys(groupedPrinters).forEach(type => {
            // Add a header for the printer type
            const headerItem = document.createElement('li');
            headerItem.className = 'collection-header';
            headerItem.innerHTML = `<h6>${type} Printers</h6>`;
            connectedPrinters.appendChild(headerItem);

            // Add printers of this type with radio buttons for selection
            groupedPrinters[type].forEach(printer => {
              const listItem = document.createElement('li');
              listItem.className = 'collection-item';

              // Create radio button
              const radioInput = document.createElement('input');
              radioInput.type = 'radio';
              radioInput.name = 'selectedPrinter';
              radioInput.id = printer.id;
              radioInput.value = JSON.stringify(printer); // Serialize printer object

              // Create label for radio button
              const label = document.createElement('label');
              label.htmlFor = printer.id;
              let printerInfo = `${printer.deviceName}`;
              
              // Append additional info based on printer type
              if (type === 'USB') {
                printerInfo += ` (Vendor ID: ${printer.vendorId}, Product ID: ${printer.productId})`;
              } else if (type === 'Ethernet') {
                printerInfo += ` (IP: ${printer.ipAddress}, Port: ${printer.port})`;
              } else if (type === 'Bluetooth') {
                printerInfo += ` (Address: ${printer.address})`;
              }

              label.textContent = printerInfo;
              
              // Append radio button and label to list item
              listItem.appendChild(radioInput);
              listItem.appendChild(label);
              connectedPrinters.appendChild(listItem);
            });

            // Add a horizontal line separator after each group
            const separator = document.createElement('hr');
            connectedPrinters.appendChild(separator);
          });
        })
        .catch(error => {
          console.error('Error fetching printers:', error);
          log('Failed to load printers.');
        });
    }

    // Function to handle Print Hello World button click
    document.getElementById('printHello').addEventListener('click', () => {
      const selectedPrinterRadio = document.querySelector('input[name="selectedPrinter"]:checked');
      if (!selectedPrinterRadio) {
        log('Please select a printer to print.');
        return;
      }

      const selectedPrinter = JSON.parse(selectedPrinterRadio.value);

      fetch('/print', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ printer: selectedPrinter, message: 'Hello World' })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          log('Print job sent successfully.');
        } else {
          log(`Error: ${data.error}`);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        log('Failed to send print job.');
      });
    });

    // Function to validate subnet format
    function isValidSubnet(subnet) {
      const subnetPattern = /^(\d{1,3}\.){3}$/;
      return subnetPattern.test(subnet);
    }
  </script>
</body>
</html>